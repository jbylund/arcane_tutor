name: CI Monitor

on:
  schedule:
    # Run every 3 hours
    - cron: '0 */3 * * *'
  workflow_dispatch: # Allow manual triggering for testing

permissions:
  contents: read
  issues: write

jobs:
  check-ci-status:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check CI status on main branch
        id: ci-check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get the latest commit on main branch
            const { data: mainBranch } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'main'
            });
            
            const latestCommitSha = mainBranch.commit.sha;
            console.log(`Latest commit on main: ${latestCommitSha}`);
            
            // Get recent workflow runs for main branch to check their status
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            let hasFailed = false;
            let failedChecks = [];
            
            // Check each workflow's recent runs on main branch
            for (const workflow of workflows.workflows) {
              // Skip the CI Monitor workflow itself
              if (workflow.name === 'CI Monitor' || workflow.path.includes('ci-monitor')) {
                continue;
              }
              
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.id,
                  branch: 'main',
                  per_page: 1
                });
                
                if (runs.workflow_runs.length > 0) {
                  const latestRun = runs.workflow_runs[0];
                  console.log(`Workflow: ${workflow.name} - Latest run: ${latestRun.conclusion} (${latestRun.head_sha})`);
                  
                  // Check if this run is for the latest commit and failed
                  if (latestRun.head_sha === latestCommitSha && latestRun.conclusion === 'failure') {
                    hasFailed = true;
                    failedChecks.push({
                      name: workflow.name,
                      type: 'workflow',
                      url: latestRun.html_url,
                      conclusion: latestRun.conclusion
                    });
                  }
                }
              } catch (error) {
                console.log(`Error checking workflow ${workflow.name}: ${error.message}`);
              }
            }
            
            console.log(`Total failed checks: ${failedChecks.length}`);
            core.setOutput('has_failed', hasFailed);
            core.setOutput('failed_checks', JSON.stringify(failedChecks));
            core.setOutput('commit_sha', latestCommitSha);
            
            return { hasFailed, failedChecks, commitSha: latestCommitSha };

      - name: Create issue if CI failed
        if: steps.ci-check.outputs.has_failed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const failedChecks = JSON.parse('${{ steps.ci-check.outputs.failed_checks }}');
            const commitSha = '${{ steps.ci-check.outputs.commit_sha }}';
            
            // Check if there's already an open issue for CI failures
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure',
              creator: 'github-actions[bot]'
            });
            
            // If there's already an open CI failure issue, don't create another one
            if (existingIssues.length > 0) {
              console.log('CI failure issue already exists, skipping creation');
              return;
            }
            
            // Format the failed checks for the issue body
            let checksMarkdown = '';
            for (const check of failedChecks) {
              checksMarkdown += `- **${check.name}** (${check.type})\n`;
              if (check.url) {
                checksMarkdown += `  - [View details](${check.url})\n`;
              }
            }
            
            const issueTitle = `CI Checks Failing on Main Branch (${commitSha.substring(0, 7)})`;
            const issueBody = `## CI Failure Detected
            
The automated CI monitor has detected failing checks on the main branch.

**Commit:** ${commitSha}
**Failed Checks:**

${checksMarkdown}

**What to do:**
1. Review the failing checks above
2. Fix any linting errors by running: \`python -m ruff check --fix --unsafe-fixes\`
3. Fix any failing tests by running: \`python -m pytest -vvv\`
4. Commit and push the fixes to main branch
5. Close this issue once CI passes

This issue was automatically created by the CI monitoring workflow.`;

            // Create the issue
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['ci-failure', 'bug'],
              assignees: ['copilot']
            });
            
            console.log(`Created issue #${issue.number}: ${issueTitle}`);

      - name: Log CI status
        run: |
          echo "CI Status Check Complete"
          echo "Has Failed: ${{ steps.ci-check.outputs.has_failed }}"
          echo "Commit SHA: ${{ steps.ci-check.outputs.commit_sha }}"