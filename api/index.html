<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Search for Magic: The Gathering cards. Find MTG cards by name, type, text, mana cost, and more. Open source Scryfall implementation."
    />
    <meta name="theme-color" content="#2b8fdf" />
    <meta property="og:title" content="Arcane Tutor - Magic: The Gathering Card Search" />
    <meta
      property="og:description"
      content="Search for Magic: The Gathering cards by name, type, text, mana cost, and more."
    />
    <meta property="og:type" content="website" />
    <title>Arcane Tutor - Magic: The Gathering Card Search</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="preconnect" href="https://d1hot9ps2xugbc.cloudfront.net" />
    <link rel="preconnect" href="https://d1hot9ps2xugbc.cloudfront.net" crossorigin />
    <link
      rel="preload"
      as="font"
      type="font/woff2"
      href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/beleren/beleren-subset.woff2"
      crossorigin
    />
    <link
      href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/mana/mana-subset.css"
      rel="stylesheet"
      type="text/css"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/mana/mana-subset.css"
        rel="stylesheet"
        type="text/css"
      />
    </noscript>
    <link
      href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/beleren/beleren-subset.css"
      rel="stylesheet"
      type="text/css"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/beleren/beleren-subset.css"
        rel="stylesheet"
        type="text/css"
      />
    </noscript>
    <link
      href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/mplantin/mplantin-subset.css"
      rel="stylesheet"
      type="text/css"
      media="print"
      onload="this.media='all'"
    />
    <noscript>
      <link
        href="https://d1hot9ps2xugbc.cloudfront.net/cdn/fonts/mplantin/mplantin-subset.css"
        rel="stylesheet"
        type="text/css"
      />
    </noscript>
    <style>
      /* Font fallback adjustments to prevent layout shift when web fonts load
       * Metrics calculated from actual font files using fontTools
       * Beleren: x-height 500/1000, Liberation Sans: x-height 1082/2048
       * MPlantin: x-height 455/1000, Liberation Serif: x-height 940/2048
       */

      /* Beleren fallback: Use Arial/Liberation Sans Bold with adjusted metrics */
      @font-face {
        font-family: 'Beleren Fallback';
        src: local('Arial Bold'), local('Liberation Sans Bold');
        font-weight: bold;
        font-style: normal;
        size-adjust: 94.6%;
        ascent-override: 96.2%;
        descent-override: 89.9%;
        line-gap-override: 23.9%;
      }

      /* MPlantin fallback: Use Georgia/Liberation Serif with adjusted metrics */
      @font-face {
        font-family: 'MPlantin Fallback';
        src: local('Georgia'), local('Liberation Serif');
        font-weight: normal;
        font-style: normal;
        size-adjust: 99.1%;
        ascent-override: 99.9%;
        descent-override: 88.2%;
        line-gap-override: 28.7%;
      }

      :root {
        /* Default colors (fallback) */
        --color-primary: #2b8fdf;
        --color-secondary: #1a6bb5;
      }

      [data-theme='light'] {
        /* Light Mode Colors - Blue shades inspired by Tolarian Academy */
        --color-primary: #2b8fdf;
        --color-secondary: #1a6bb5;
        --gradient-start-color: #1e7dd4;
        --gradient-end-color: #4da6e8;
        --color-background: linear-gradient(to bottom, var(--gradient-start-color) 0%, var(--gradient-end-color) 100%);
        --color-text-primary: #212529;
        --color-text-secondary: #6c757d;
        --color-text-inverted: #ffffff;
        --color-text-light: #495057;
        --color-text-lighter: #6c757d;
        --color-text-lightest: #868e96;
        --color-text-white: #ffffff;
        --color-card-background: #ffffff;
        --color-modal-background: #ffffff;
        --color-modal-text: #495057;
        --color-error: #dc3545;
        --color-text-error: #ffffff;
        --color-hover-overlay: rgba(0, 0, 0, 0.5);
        --color-shadow-light: rgba(0, 0, 0, 0.1);
        --color-shadow-medium: rgba(0, 0, 0, 0.15);
        --color-shadow-dark: rgba(0, 0, 0, 0.2);
        --color-border-light: #dee2e6;
        --color-hover-bg: #f8f9fa;
        --color-hover-text: #212529;
        --color-theme-toggle-bg: #ffffff;
        --color-theme-toggle-border: #dee2e6;
        --color-input-text: #212529;
        --color-input-background: #ffffff;
      }

      [data-theme='dark'] {
        /* Dark Mode Colors - Blue shades inspired by Tolarian Academy */
        --color-primary: #3da8f5;
        --color-secondary: #2591e6;
        --gradient-start-color: #1a3a5c;
        --gradient-end-color: #0d1829;
        --color-background: linear-gradient(to bottom, var(--gradient-start-color) 0%, var(--gradient-end-color) 100%);
        --color-text-primary: #cecece;
        --color-text-secondary: #a8a8a8;
        --color-text-inverted: #bbbbbb;
        --color-text-light: #a8a8a8;
        --color-text-lighter: #b0b0b0;
        --color-text-lightest: #ababab;
        --color-text-white: #ffffff;
        --color-card-background: rgb(58, 58, 58);
        --color-modal-background: rgb(58, 58, 58);
        --color-modal-text: #cecece;
        --color-error: #ff6b6b;
        --color-text-error: #ffffff;
        --color-hover-overlay: rgba(0, 0, 0, 0.8);
        --color-shadow-light: rgba(0, 0, 0, 0.1);
        --color-shadow-medium: rgba(0, 0, 0, 0.2);
        --color-shadow-dark: rgba(0, 0, 0, 0.3);
        --color-border-light: #e3e3e3;
        --color-hover-bg: #4a4a4a;
        --color-hover-text: #ffffff;
        --color-theme-toggle-bg: #495057;
        --color-theme-toggle-border: #6c757d;
        --color-input-text: #cecece;
        --color-input-background: #3b3b3b;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        overflow-x: hidden;
        overscroll-behavior-y: none;
        height: 100%;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background-color: var(--gradient-end-color);
        background-image: var(--color-background);
        background-repeat: no-repeat;
        background-size: 100% 200vh;
        min-height: 100vh;
        padding: 1em;
        overscroll-behavior-y: none;
        display: flex;
        flex-direction: column;
      }

      .container {
        max-width: 98vw;
        margin: 0 auto;
        flex: 1 0 auto;
        display: flex;
        flex-direction: column;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
        color: var(--color-text-inverted);
        position: relative;
      }

      .theme-toggle {
        position: absolute;
        top: 0;
        right: 0;
        background: var(--color-theme-toggle-bg);
        border: 2px solid var(--color-theme-toggle-border);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 23px;
        color: var(--color-text-primary);
        box-shadow: 0 2px 8px var(--color-shadow-light);
        z-index: 1000;
        pointer-events: auto;
      }

      .theme-toggle:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px var(--color-shadow-medium);
      }

      .theme-toggle:active {
        transform: scale(0.95);
      }

      .header h1 {
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
        font-size: 3.45rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .header h1:hover {
        transform: scale(1.05);
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
      }

      .header p {
        font-family: 'MPlantin', 'MPlantin Fallback', Georgia, serif;
        font-size: 1.38rem;
        opacity: 0.9;
      }

      .search-container {
        margin-bottom: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 15px;
      }

      .search-box {
        position: relative;
        width: 100%;
        max-width: 600px;
      }

      .order-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .dropdown-label {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      .order-dropdown {
        padding: 15px 20px;
        font-size: 1.27rem;
        border: none;
        border-radius: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        outline: none;
        background: var(--color-input-background);
        color: var(--color-input-text);
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 120px;
      }

      .order-dropdown:focus {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        background: var(--color-hover-bg);
      }

      .order-dropdown option {
        background: var(--color-input-background);
        color: var(--color-input-text);
      }

      .order-dropdown option:hover,
      .order-dropdown option:focus {
        background: var(--color-hover-bg);
        color: var(--color-hover-text);
      }

      .order-toggle {
        padding: 15px 20px;
        font-size: 1.38rem;
        border: none;
        border-radius: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        background: var(--color-input-background);
        color: var(--color-input-text);
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 60px;
        height: 54px;
      }

      .order-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        background: var(--color-hover-bg);
      }

      .order-toggle.descending .arrow-up {
        transform: rotate(180deg);
      }

      .arrow-up {
        display: inline-block;
        transition: transform 0.3s ease;
        font-weight: bold;
      }

      .search-input {
        width: 100%;
        padding: 15px 20px;
        font-size: 1.27rem;
        border: none;
        border-radius: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        outline: none;
        transition: all 0.3s ease;
        background: var(--color-input-background);
        color: var(--color-input-text);
      }

      .search-input:focus {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
      }

      .loading {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        display: none;
      }

      .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--color-border-light);
        border-top: 2px solid var(--color-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .results-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.5vw;
        margin-top: 30px;
      }

      @media (min-width: 410px) {
        .results-container {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      @media (min-width: 750px) {
        .results-container {
          grid-template-columns: repeat(3, 1fr);
        }
      }

      @media (min-width: 1370px) {
        .results-container {
          grid-template-columns: repeat(4, 1fr);
        }
      }

      @media (min-width: 2500px) {
        .results-container {
          grid-template-columns: repeat(5, 1fr);
        }
      }

      .card-item {
        background: var(--color-card-background);
        border-radius: 15px;
        padding: 0.8em;
        box-shadow: 0 10px 30px var(--color-shadow-light);
        transition: all 0.3s ease;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      .card-item:hover {
        transform: translateY(-5px);
        box-shadow: 0 20px 40px var(--color-shadow-medium);
      }

      .card-name-mana-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .card-name {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--color-text-primary);
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
        flex: 1;
      }

      .card-mana {
        font-size: 1.04rem;
        color: var(--color-text-primary);
        font-family: monospace;
        text-align: right;
      }

      .ms-cost {
        width: 1.35em;
        height: 1.35em;
      }

      .mana-symbol {
        font-family: 'Mana';
        font-size: 1em;
        margin: 0 1px;
        display: inline-block;
      }

      .card-type {
        font-size: 1.27rem;
        color: var(--color-text-primary);
        margin-bottom: 12px;
        font-style: italic;
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
      }

      .card-text {
        font-size: 1.14rem;
        color: var(--color-text-primary);
        line-height: 1.4;
        margin-bottom: 10px;
        font-family: 'MPlantin', 'MPlantin Fallback', Georgia, serif;
      }

      .card-set-power-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: auto;
      }

      .card-set {
        font-size: 0.92rem;
        color: var(--color-text-secondary);
        text-transform: uppercase;
        letter-spacing: 1px;
        flex: 1;
      }

      .card-power-toughness {
        font-size: 1.04rem;
        color: var(--color-text-primary);
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
        font-weight: bold;
        text-align: right;
      }

      /* Modal styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--color-hover-overlay);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background: var(--color-modal-background);
        border-radius: 15px;
        padding: 1em;
        max-width: 90vw;
        max-height: 90vh;
        min-height: 60vh;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 20px 60px var(--color-shadow-dark);
        animation: modalFadeIn 0.3s ease-out;
        display: flex;
        flex-direction: row;
        gap: 30px;
        align-items: stretch;
        width: fit-content;
        max-width: 90vw;
        aspect-ratio: 1.6;
      }

      @keyframes modalFadeIn {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .modal-close {
        position: absolute;
        top: 15px;
        right: 20px;
        background: none;
        border: none;
        font-size: 28px;
        cursor: pointer;
        color: var(--color-text-secondary);
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        z-index: 10;
      }

      .modal-close:hover {
        background: var(--color-hover-bg);
        color: var(--color-hover-text);
      }

      .modal-image-wrapper {
        flex: 3 0 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal-image-link {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
      }

      .modal-image {
        border-radius: 4%;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        height: auto;
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        width: auto;
        cursor: pointer;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
      }

      .modal-image:hover {
        transform: scale(1.02);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
      }

      .modal-card-info {
        display: flex;
        flex-direction: column;
        flex: 3 0 0;
        min-height: 0;
        min-width: 0;
        overflow-y: auto;
        padding-right: 10px;
        text-align: left;
      }

      .modal-card-name-mana-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 50px;
        margin-bottom: 8px;
      }

      .modal-card-name {
        font-size: 1.73rem;
        font-weight: bold;
        color: var(--color-text-light);
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
        flex: 1;
      }

      .modal-card-mana {
        font-size: 1.27rem;
        color: var(--color-text-lighter);
        font-family: monospace;
        text-align: right;
      }

      .modal-mana-symbol {
        font-family: 'Mana';
        font-size: 1.08em;
        margin: 0 1px;
        display: inline-block;
      }

      .modal-card-type {
        font-size: 1.39rem;
        color: var(--color-text-lightest);
        margin-bottom: 12px;
        font-style: italic;
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
      }

      .modal-card-text {
        font-size: 1.27rem;
        color: var(--color-text-lightest);
        line-height: 1.6;
        margin-bottom: 10px;
        text-align: left;
        font-family: 'MPlantin', 'MPlantin Fallback', Georgia, serif;
      }

      .modal-card-set-power-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: auto;
      }

      .modal-card-set {
        font-size: 1.04rem;
        color: var(--color-modal-text);
        text-transform: uppercase;
        letter-spacing: 1px;
        flex: 1;
      }

      .modal-card-power-toughness {
        font-size: 1.27rem;
        color: var(--color-modal-text);
        font-family: 'Beleren', 'Beleren Fallback', sans-serif;
        font-weight: bold;
        text-align: right;
      }

      .error-message {
        background: var(--color-error);
        color: var(--color-text-error);
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin-top: 20px;
      }

      .no-results {
        text-align: center;
        color: var(--color-text-inverted);
        font-size: 1.38rem;
        margin-top: 40px;
        opacity: 0.8;
      }

      .results-count {
        color: var(--color-text-inverted);
        text-align: center;
        margin-bottom: 20px;
        font-size: 1.27rem;
      }
      #statusMessage {
        min-height: 2.8rem;
        margin-bottom: 20px;
      }

      .card-image {
        display: block;
        width: 100%;
        height: auto;
        max-width: min(400px, 35vw);
        margin: 0 auto 10px auto;
        border-radius: 5.5% / 4%;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      }

      .footer {
        margin-top: auto;
        padding: 30px 20px;
        text-align: center;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--color-text-inverted);
        flex-shrink: 0;
      }

      .footer-legal {
        font-size: 0.98em;
        line-height: 1.6;
        margin-bottom: 12px;
      }

      .footer-attribution {
        font-size: 0.98em;
        line-height: 1.6;
        margin-bottom: 12px;
      }

      .footer-attribution a {
        color: var(--color-text-white);
        text-decoration: underline;
        font-weight: 500;
      }

      .footer-attribution a:hover {
        text-decoration: underline;
      }

      .footer-links {
        font-size: 0.98em;
        margin-top: 15px;
      }

      .footer-links a {
        color: var(--color-text-white);
        text-decoration: underline;
        padding: 0 8px;
      }

      .footer-links a:hover {
        text-decoration: underline;
      }

      @media (max-width: 1200px) {
        .container {
          max-width: 98vw;
        }
      }

      @media (max-width: 768px) {
        .header h1 {
          font-size: 2.3rem;
        }

        .theme-toggle {
          width: 45px;
          height: 45px;
          font-size: 21px;
        }

        .search-container {
          flex-direction: column;
          gap: 10px;
        }

        .order-controls {
          width: 100%;
          justify-content: center;
          flex-wrap: wrap;
        }

        .order-dropdown {
          flex: 1;
          max-width: 140px;
          min-width: 90px;
        }

        .footer {
          margin-top: 40px;
          padding: 20px 10px;
        }

        .footer-legal,
        .footer-attribution,
        .footer-links {
          padding: 12px 15px;
          font-size: 1.09rem;
        }

        .order-toggle {
          padding: 12px 15px;
          min-width: 50px;
          height: 48px;
        }

        .card-image {
          max-width: min(400px, 35vw);
        }

        body {
          padding: 15px;
        }

        .modal-content {
          padding: 1em;
          max-width: 95vw;
          max-height: 90vh;
          flex-direction: column;
          gap: 20px;
          overflow-y: auto;
        }

        .modal-image {
          max-width: min(350px, 70vw);
          max-height: none;
          margin-bottom: 0;
          align-self: center;
          flex-shrink: 0;
        }

        .modal-card-name {
          font-size: 1.5rem;
        }

        .modal-card-mana,
        .modal-card-type {
          font-size: 1.27rem;
        }

        .modal-card-text {
          font-size: 1.14rem;
        }

        .modal-card-info {
          text-align: center;
          overflow-y: visible;
          flex-shrink: 0;
          padding-bottom: 20px;
        }
      }

      @media (max-width: 480px) {
        .card-image {
          max-width: 100%;
        }

        .order-dropdown {
          max-width: 110px;
          min-width: 80px;
          padding: 10px 12px;
          font-size: 1.04rem;
        }

        .order-toggle {
          padding: 10px 12px;
          min-width: 45px;
          height: 42px;
          font-size: 1.15rem;
        }
      }
    </style>
    <script>
      const UNIQUE_PRINTING = 'printing';
      class CardSearch {
        constructor() {
          this.searchForm = document.querySelector('.search-container');
          this.searchInput = document.getElementById('searchInput');
          this.resultsContainer = document.getElementById('results');
          this.loadingIndicator = document.getElementById('loading');
          this.statusMessage = document.getElementById('statusMessage');
          this.orderDropdown = document.getElementById('orderDropdown');
          this.uniqueDropdown = document.getElementById('uniqueDropdown');
          this.preferDropdown = document.getElementById('preferDropdown');
          this.orderToggle = document.getElementById('orderToggle');
          this.directionInput = document.getElementById('directionInput');

          // Disable browser autocomplete when JavaScript is enabled
          this.searchInput.setAttribute('autocomplete', 'off');

          this.debounceTimeout = null;
          this.debounceDelay = 140; // milliseconds
          this.currentController = null;
          this.imageObserver = null;
          this.cardsData = new Map(); // Store card data by ID
          this.lastRequestedUrl = null; // Track the last requested URL to prevent duplicate requests
          this.isAscending = true; // Track order direction
          this.currentCardCount = 0; // Track current number of cards displayed for resize handling

          // Autocomplete properties
          this.commonCardTypes = []; // Will store the common card types

          // Initialize cached regex patterns for mana symbol replacement (performance optimization)
          this.initManaSymbolPatterns();

          this.init();
        }

        initManaSymbolPatterns() {
          // Define mana symbol maps once
          const manaMap = {
            '{R}': 'ms ms-r ms-cost',
            '{G}': 'ms ms-g ms-cost',
            '{W}': 'ms ms-w ms-cost',
            '{U}': 'ms ms-u ms-cost',
            '{B}': 'ms ms-b ms-cost',
            '{C}': 'ms ms-c ms-cost',
            '{0}': 'ms ms-0 ms-cost',
            '{1}': 'ms ms-1 ms-cost',
            '{2}': 'ms ms-2 ms-cost',
            '{3}': 'ms ms-3 ms-cost',
            '{4}': 'ms ms-4 ms-cost',
            '{5}': 'ms ms-5 ms-cost',
            '{6}': 'ms ms-6 ms-cost',
            '{7}': 'ms ms-7 ms-cost',
            '{8}': 'ms ms-8 ms-cost',
            '{9}': 'ms ms-9 ms-cost',
            '{10}': 'ms ms-10 ms-cost',
            '{11}': 'ms ms-11 ms-cost',
            '{12}': 'ms ms-12 ms-cost',
            '{13}': 'ms ms-13 ms-cost',
            '{14}': 'ms ms-14 ms-cost',
            '{15}': 'ms ms-15 ms-cost',
            '{16}': 'ms ms-16 ms-cost',
            '{X}': 'ms ms-x ms-cost',
            '{Y}': 'ms ms-y ms-cost',
            '{Z}': 'ms ms-z ms-cost',
            '{T}': 'ms ms-tap',
            '{Q}': 'ms ms-untap',
            '{E}': 'ms ms-energy',
            '{P}': 'ms ms-p ms-cost',
            '{S}': 'ms ms-s ms-cost',
            '{CHAOS}': 'ms ms-chaos',
            '{PW}': 'ms ms-pw',
            '{âˆž}': 'ms ms-infinity',
          };

          const hybridMap = {
            '{W/U}': 'ms ms-wu ms-cost',
            '{U/B}': 'ms ms-ub ms-cost',
            '{B/R}': 'ms ms-br ms-cost',
            '{R/G}': 'ms ms-rg ms-cost',
            '{G/W}': 'ms ms-gw ms-cost',
            '{W/B}': 'ms ms-wb ms-cost',
            '{U/R}': 'ms ms-ur ms-cost',
            '{B/G}': 'ms ms-bg ms-cost',
            '{R/W}': 'ms ms-rw ms-cost',
            '{G/U}': 'ms ms-gu ms-cost',
            '{2/W}': 'ms ms-2w ms-cost',
            '{2/U}': 'ms ms-2u ms-cost',
            '{2/B}': 'ms ms-2b ms-cost',
            '{2/R}': 'ms ms-2r ms-cost',
            '{2/G}': 'ms ms-2g ms-cost',
            '{W/P}': 'ms ms-wp ms-cost',
            '{U/P}': 'ms ms-up ms-cost',
            '{B/P}': 'ms ms-bp ms-cost',
            '{R/P}': 'ms ms-rp ms-cost',
            '{G/P}': 'ms ms-gp ms-cost',
            '{W/U/P}': 'ms ms-wup ms-cost',
            '{W/B/P}': 'ms ms-wbp ms-cost',
            '{U/B/P}': 'ms ms-ubp ms-cost',
            '{U/R/P}': 'ms ms-urp ms-cost',
            '{B/R/P}': 'ms ms-brp ms-cost',
            '{B/G/P}': 'ms ms-bgp ms-cost',
            '{R/W/P}': 'ms ms-rwp ms-cost',
            '{R/G/P}': 'ms ms-rgp ms-cost',
            '{G/W/P}': 'ms ms-gwp ms-cost',
            '{G/U/P}': 'ms ms-gup ms-cost',
          };

          const manaTextMap = {
            '{W}': 'â˜€ï¸',
            '{U}': 'ðŸ’§',
            '{B}': 'ðŸ’€',
            '{R}': 'ðŸ”¥',
            '{G}': 'ðŸŒ³',
            '{C}': 'â—‡',
            '{T}': 'â†»',
            '{Q}': 'â†º',
            '{E}': 'âš¡',
            '{P}': 'Î¦',
            '{S}': 'â„',
            '{X}': 'X',
            '{Y}': 'Y',
            '{Z}': 'Z',
            '{0}': 'â“ª',
            '{1}': 'â‘ ',
            '{2}': 'â‘¡',
            '{3}': 'â‘¢',
            '{4}': 'â‘£',
            '{5}': 'â‘¤',
            '{6}': 'â‘¥',
            '{7}': 'â‘¦',
            '{8}': 'â‘§',
            '{9}': 'â‘¨',
            '{10}': 'â‘©',
            '{11}': 'â‘ª',
            '{12}': 'â‘«',
            '{13}': 'â‘¬',
            '{14}': 'â‘­',
            '{15}': 'â‘®',
            '{16}': 'â‘¯',
            '{CHAOS}': 'ðŸŒ€',
            '{PW}': 'PW',
            '{âˆž}': 'â™¾ï¸Ž',
            '{W/U}': '(â˜€ï¸/ðŸ’§)',
            '{U/B}': '(ðŸ’§/ðŸ’€)',
            '{B/R}': '(ðŸ’€/ðŸ”¥)',
            '{R/G}': '(ðŸ”¥/ðŸŒ³)',
            '{G/W}': '(ðŸŒ³/â˜€ï¸)',
            '{W/B}': '(â˜€ï¸/ðŸ’€)',
            '{U/R}': '(ðŸ’§/ðŸ”¥)',
            '{B/G}': '(ðŸ’€/ðŸŒ³)',
            '{R/W}': '(ðŸ”¥/â˜€ï¸)',
            '{G/U}': '(ðŸŒ³/ðŸ’§)',
            '{2/W}': '(â‘¡/â˜€ï¸)',
            '{2/U}': '(â‘¡/ðŸ’§)',
            '{2/B}': '(â‘¡/ðŸ’€)',
            '{2/R}': '(â‘¡/ðŸ”¥)',
            '{2/G}': '(â‘¡/ðŸŒ³)',
            '{W/P}': '(â˜€ï¸/Î¦)',
            '{U/P}': '(ðŸ’§/Î¦)',
            '{B/P}': '(ðŸ’€/Î¦)',
            '{R/P}': '(ðŸ”¥/Î¦)',
            '{G/P}': '(ðŸŒ³/Î¦)',
            '{W/U/P}': '(â˜€ï¸/ðŸ’§/Î¦)',
            '{W/B/P}': '(â˜€ï¸/ðŸ’€/Î¦)',
            '{U/B/P}': '(ðŸ’§/ðŸ’€/Î¦)',
            '{U/R/P}': '(ðŸ’§/ðŸ”¥/Î¦)',
            '{B/R/P}': '(ðŸ’€/ðŸ”¥/Î¦)',
            '{B/G/P}': '(ðŸ’€/ðŸŒ³/Î¦)',
            '{R/W/P}': '(ðŸ”¥/â˜€ï¸/Î¦)',
            '{R/G/P}': '(ðŸ”¥/ðŸŒ³/Î¦)',
            '{G/W/P}': '(ðŸŒ³/â˜€ï¸/Î¦)',
            '{G/U/P}': '(ðŸŒ³/ðŸ’§/Î¦)',
          };

          // Cache the merged symbol map for convertManaSymbols
          // Use simple pattern that matches any content between braces (1-5 chars)
          // Use Map for O(1) lookup with single get() operation
          this.manaSymbolsMap = new Map(Object.entries({ ...hybridMap, ...manaMap }));
          this.manaSymbolsRegex = /\{[^}]{1,5}\}/g;

          // Cache the text map for convertManaSymbolsToText
          this.manaTextMap = new Map(Object.entries(manaTextMap));
          this.manaTextRegex = /\{[^}]{1,5}\}/g;
        }

        async init() {
          // Fetch common card types first
          await this.fetchCommonCardTypes();

          // Initialize intersection observer for lazy image loading BEFORE displaying any results
          this.initImageObserver();

          // On page load, check for query params and restore state
          const params = new URLSearchParams(window.location.search);
          const initialQuery = params.get('q') || '';
          const initialOrder = params.get('orderby') || 'edhrec';
          const initialDirection = params.get('direction') || 'asc';
          const initialUnique = params.get('unique') || 'card';
          const initialPrefer = params.get('prefer') || 'default';

          // Set the order controls to match URL params
          this.orderDropdown.value = initialOrder;
          this.uniqueDropdown.value = initialUnique;
          this.preferDropdown.value = initialPrefer;
          this.isAscending = initialDirection === 'asc';
          this.directionInput.value = initialDirection;
          this.updateOrderToggleAppearance();
          this.updatePreferVisibility();

          if (initialQuery) {
            this.searchInput.value = initialQuery;
            // Check if we have embedded search results from the server
            if (window.EMBEDDED_SEARCH_RESULTS) {
              // Use the embedded results directly without making an API call
              this.displayResults(window.EMBEDDED_SEARCH_RESULTS, initialQuery, null);
              // Clear the embedded results so they're not reused
              delete window.EMBEDDED_SEARCH_RESULTS;
            } else {
              // No embedded results, perform the search via API
              this.performSearch(initialQuery);
            }
          }

          // Prevent form submission when JavaScript is enabled
          this.searchForm.addEventListener('submit', e => {
            e.preventDefault();
            const query = this.searchInput.value.trim();
            if (query) {
              clearTimeout(this.debounceTimeout);
              this.performSearch(query);
            }
          });

          this.searchInput.addEventListener('input', e => {
            const query = e.target.value;
            this.handleSearch(query);
            // Update the URL as the user types
            const order = this.orderDropdown.value;
            const unique = this.uniqueDropdown.value;
            const prefer = this.preferDropdown.value;
            const direction = this.isAscending ? 'asc' : 'desc';
            this.updateURL(query, order, direction, unique, prefer);
          });

          // Handle enter key for immediate search
          this.searchInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') {
              clearTimeout(this.debounceTimeout);
              this.performSearch(e.target.value);
            }
          });

          // Add event delegation for card clicks
          this.resultsContainer.addEventListener('click', e => {
            const cardItem = e.target.closest('.card-item');
            if (cardItem) {
              this.handleCardClick(cardItem);
            }
          });

          // Add click handler for header to clear search
          document.querySelector('.header h1').addEventListener('click', () => {
            this.clearSearch();
          });

          // Add event listeners for order controls
          this.orderDropdown.addEventListener('change', () => {
            this.handleOrderChange();
          });

          this.uniqueDropdown.addEventListener('change', () => {
            this.updatePreferVisibility();
            this.handleUniqueChange();
          });

          this.preferDropdown.addEventListener('change', () => {
            this.handlePreferChange();
          });

          this.orderToggle.addEventListener('click', () => {
            this.toggleOrderDirection();
          });

          // Add resize listener to update columns dynamically
          window.addEventListener('resize', () => {
            this.updateGridColumns(this.currentCardCount);
          });
        }

        handleSearch(query) {
          // Clear previous timeout
          clearTimeout(this.debounceTimeout);

          // Cancel previous request if still pending
          if (this.currentController) {
            this.currentController.abort();
          }

          // Clear results if query is empty
          if (!query.trim()) {
            this.clearResults();
            this.lastRequestedUrl = null; // Reset URL tracking when clearing
            return;
          }

          // Set up debounced search
          this.debounceTimeout = setTimeout(() => {
            this.performSearch(query);
          }, this.debounceDelay);
        }

        async fetchCommonCardTypes() {
          try {
            const response = await fetch('/get_common_card_types');
            if (!response.ok) {
              throw new Error('Failed to fetch common card types');
            }
            this.commonCardTypes = await response.json();
            console.debug('Loaded', this.commonCardTypes.length, 'common card types');
          } catch (error) {
            console.error('Error fetching common card types:', error);
            this.commonCardTypes = [];
          }
        }

        autoCompleteQuery(query) {
          // Look for type queries like "t:hydr" or "type:hydr"
          const typeMatch = query.match(/(?:^|\s)(?:t|type):([a-zA-Z]*)$/i);
          if (!typeMatch) {
            return query; // No type query found, return original
          }

          const prefix = typeMatch[1].toLowerCase();
          if (prefix.length < 2) {
            // Only autocomplete if at least 2 characters
            return query;
          }

          // Find the most common type that starts with this prefix
          const bestMatch = this.commonCardTypes
            .filter(type => type.t.toLowerCase().startsWith(prefix))
            .sort((a, b) => b.n - a.n)[0]; // Get the most frequent match

          if (!bestMatch) {
            return query; // No match found, return original
          }

          // Get the original prefix to preserve capitalization
          const originalPrefix = typeMatch[1];

          // Create completion that matches the user's capitalization pattern
          let completedType = bestMatch.t;
          if (originalPrefix.length > 0) {
            // Preserve the capitalization pattern of the user's input
            if (originalPrefix === originalPrefix.toUpperCase()) {
              // All caps -> all caps
              completedType = bestMatch.t.toUpperCase();
            } else if (originalPrefix === originalPrefix.toLowerCase()) {
              // All lowercase -> all lowercase
              completedType = bestMatch.t.toLowerCase();
            } else {
              // Mixed case -> take whatever they've typed so far
              // and append the rest of the completion
              completedType = originalPrefix + bestMatch.t.slice(originalPrefix.length);
            }
          }

          // Auto-complete the query
          const completedQuery = query.replace(/(?:^|\s)(?:t|type):[a-zA-Z]*$/i, match => {
            return match.replace(/[a-zA-Z]+$/, completedType);
          });

          return completedQuery;
        }

        balanceQuery(query) {
          // Balance quotes and parentheses for typeahead searches using a stack
          const charToMirror = {
            '(': ')',
            "'": "'", // single quote is own mirror
            '"': '"', // double quote is own mirror
            ')': '(',
          };

          const stack = [];

          // Process each character in the query
          for (let i = 0; i < query.length; i++) {
            const char = query[i];
            const mirroredChar = charToMirror[char];

            if (!mirroredChar) {
              continue;
            }

            if (stack.length > 0 && stack[stack.length - 1] === mirroredChar) {
              stack.pop();
            } else {
              stack.push(char);
            }
          }

          // Build the closing characters from the stack in reverse order
          let closing = '';
          while (stack.length > 0) {
            const char = stack.pop();
            closing += charToMirror[char];
          }

          return query + closing;
        }

        async performSearch(query) {
          if (!query.trim()) return;

          // First, try to autocomplete the query
          const completedQuery = this.autoCompleteQuery(query);

          // Balance the query for better typeahead results
          const balancedQuery = this.balanceQuery(completedQuery);

          // Normalize whitespace to prevent duplicate requests for queries that differ only in whitespace
          const normalizedQuery = balancedQuery.trim().replace(/\s+/g, ' ');

          // Get current order settings
          const order = this.orderDropdown.value;
          const unique = this.uniqueDropdown.value;
          const prefer = this.preferDropdown.value;
          const orderDirection = this.isAscending ? 'asc' : 'desc';

          // Generate the URL for this request
          const url = `/search?q=${encodeURIComponent(normalizedQuery)}&orderby=${order}&direction=${orderDirection}&unique=${unique}&prefer=${prefer}`;

          // Check if this is the same URL as the last request - if so, skip the request
          if (this.lastRequestedUrl === url) {
            console.log('Skipping duplicate request for URL:', url);
            return;
          }

          // Show loading state
          this.showLoading();
          this.clearMessages();

          // Create new AbortController for this request
          this.currentController = new AbortController();
          // Update the last requested URL
          this.lastRequestedUrl = url;

          try {
            // Clear any previous resource timing entries for this URL
            performance.clearResourceTimings && performance.clearResourceTimings();
            // Take a timestamp just before sending the request
            const startTimestampMs = performance.now();
            const response = await fetch(url, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
              },
              signal: this.currentController.signal,
            });
            if (!response.ok) {
              // Try to get the error message from the response body
              let errorMessage = `HTTP error! status: ${response.status}`;
              try {
                const errorData = await response.json();
                if (errorData.title && errorData.description) {
                  // If description is an object (like with 500 errors), just use the title
                  if (typeof errorData.description === 'object') {
                    errorMessage = errorData.title;
                  } else {
                    errorMessage = `${errorData.title}: ${errorData.description}`;
                  }
                } else if (errorData.description) {
                  // Only use description if it's a string, not an object
                  if (typeof errorData.description === 'string') {
                    errorMessage = errorData.description;
                  }
                }
              } catch {
                // If we can't parse the error response, use the generic message
              }
              throw new Error(errorMessage);
            }
            const data = await response.json();

            // Compute round-trip duration from our own timestamps
            const computedRoundTripMs = Math.round(performance.now() - startTimestampMs);

            // Use PerformanceResourceTiming to get the network time
            let elapsed = null;
            const resources = performance.getEntriesByType('resource');
            // Find the most recent entry for this URL
            // (If there are multiple, pick the last one)
            const matching = resources.filter(e => e.name.includes(url));
            if (matching.length > 0) {
              const entry = matching[matching.length - 1];
              // responseEnd - startTime is the total time as shown in dev tools
              elapsed = Math.round(entry.responseEnd - entry.startTime);
            }
            // Use the minimum of PerformanceResourceTiming and our computed duration
            if (typeof elapsed === 'number') {
              elapsed = Math.min(elapsed, computedRoundTripMs);
            } else {
              elapsed = computedRoundTripMs;
            }
            this.displayResults(data, normalizedQuery, elapsed);
          } catch (error) {
            if (error.name === 'AbortError') {
              // Request was cancelled, ignore
              return;
            }
            console.error('Search error:', error);
            this.showError(`Failed to search: ${error.message}`);
          } finally {
            this.currentController = null;
          }
        }

        displayResults(data, query, elapsed) {
          // Assume the API returns an array of cards or an object with a cards array
          const cards = Array.isArray(data) ? data : data.cards || [];
          const totalCards = data.total_cards || cards.length;

          if (cards.length === 0) {
            this.showNoResults();
            return;
          }

          // Clear previous card data and store new cards
          this.cardsData.clear();
          cards.forEach((card, index) => {
            const cardId = index.toString();
            console.debug('Storing card with ID:', cardId, 'Card data:', card);
            this.cardsData.set(cardId, card);
          });

          console.debug('Total cards stored in cardsData:', this.cardsData.size);
          console.debug('CardsData keys:', Array.from(this.cardsData.keys()));

          this.showResultsCount(totalCards, query, elapsed);

          // Store card count for resize handling
          this.currentCardCount = cards.length;

          // Set max columns based on card count to prevent more columns than cards
          this.updateGridColumns(cards.length);

          // Calculate number of columns in the first row for fetchpriority
          const firstRowCount = this.calculateFirstRowCount(cards.length);

          this.resultsContainer.innerHTML = cards
            .map((card, index) => this.createCardHTML(card, index, index < firstRowCount))
            .join('');

          // Observe all images for viewport-based loading
          this.observeImages();
        }

        getColumnsFromViewportWidth() {
          // Determine columns based on screen width breakpoints
          const viewportWidth = window.innerWidth;

          if (viewportWidth < 410) {
            return 1;
          } else if (viewportWidth < 750) {
            return 2;
          } else if (viewportWidth < 1370) {
            return 3;
          } else if (viewportWidth < 2500) {
            return 4;
          } else {
            return 5;
          }
        }

        calculateFirstRowCount(cardCount) {
          // Calculate how many cards fit in the first row based on viewport width and card count
          const columnsFromWidth = this.getColumnsFromViewportWidth();

          // Return the minimum of columns from width and card count
          return Math.min(columnsFromWidth, cardCount);
        }

        updateGridColumns(cardCount) {
          // Only update if we have cards displayed
          if (cardCount === 0) {
            return;
          }

          // Determine columns based on screen width breakpoints
          const columnsFromWidth = this.getColumnsFromViewportWidth();

          // Use the minimum of columns from width and card count
          const actualColumns = Math.min(columnsFromWidth, cardCount);

          // Set the grid-template-columns directly
          this.resultsContainer.style.gridTemplateColumns = `repeat(${actualColumns}, 1fr)`;
        }

        buildImageUrl(card, size) {
          return `https://d1hot9ps2xugbc.cloudfront.net/img/${card.set_code}/${card.collector_number}/${size}.webp`;
        }

        createCardHTML(card, index, isFirstRow = false) {
          const cardId = index.toString();

          const imageSmall = this.buildImageUrl(card, '220');
          const imageNormal = this.buildImageUrl(card, '410');
          const imageLarge = this.buildImageUrl(card, '745');

          // Debug logging
          console.debug('Creating card HTML for:', card);
          console.debug('Card ID will be:', cardId);

          // Create descriptive alt text with card name, mana cost, and oracle text
          let altText = this.escapeHtml(card.name || 'Unknown Card');
          if (card.mana_cost) {
            // Convert mana symbols to Unicode for alt text
            const manaTextRepresentation = this.convertManaSymbolsToText(card.mana_cost);
            altText += ` / ${this.escapeHtml(manaTextRepresentation)}`;
          }
          altText += '\n\n';
          if (card.oracle_text) {
            // Convert mana symbols in oracle text to Unicode for alt text first, then truncate
            const oracleTextWithSymbols = this.convertManaSymbolsToText(card.oracle_text);
            const maxLength = 300;
            const truncatedText =
              oracleTextWithSymbols.length > maxLength
                ? oracleTextWithSymbols.substring(0, maxLength) + '...'
                : oracleTextWithSymbols;
            altText += this.escapeHtml(truncatedText);
          }

          // Create placeholder image that will be replaced when in viewport
          // Add fetchpriority="high" for first row cards to improve LCP
          // Add loading="lazy" for non-first-row images to improve initial load
          const fetchPriorityAttr = isFirstRow ? ' fetchpriority="high"' : '';
          const loadingAttr = isFirstRow ? '' : ' loading="lazy"';
          const imageHtml = `<img class="card-image" data-small="${this.escapeHtml(imageSmall)}" data-normal="${this.escapeHtml(imageNormal)}" data-large="${this.escapeHtml(imageLarge)}" width="410" height="573" alt="${altText}" title="${altText}"${fetchPriorityAttr}${loadingAttr} />`;

          return `
             <div class="card-item" data-card-id="${this.escapeHtml(cardId)}">
                 ${imageHtml}
                 <div class="card-name-mana-row">
                     <div class="card-name">${this.escapeHtml(card.name || 'Unknown Card')}</div>
                     ${card.mana_cost ? `<div class="card-mana">${this.convertManaSymbols(card.mana_cost, false)}</div>` : ''}
                 </div>
                 ${card.type_line ? `<div class="card-type">${this.escapeHtml(card.type_line)}</div>` : ''}
                 ${card.oracle_text ? `<div class="card-text">${this.formatOracleText(card.oracle_text.substring(0, 200), false)}${card.oracle_text.length > 200 ? '...' : ''}</div>` : ''}
                 ${(() => {
                   const hasPowerToughness =
                     card.power !== null &&
                     card.power !== undefined &&
                     card.toughness !== null &&
                     card.toughness !== undefined;
                   return card.set_name || hasPowerToughness
                     ? `
                 <div class="card-set-power-row">
                     ${card.set_name ? `<div class="card-set">${this.escapeHtml(card.set_name)}</div>` : '<div class="card-set"></div>'}
                     ${hasPowerToughness ? `<div class="card-power-toughness">${this.escapeHtml(card.power)} / ${this.escapeHtml(card.toughness)}</div>` : ''}
                 </div>
                 `
                     : '';
                 })()}
             </div>
         `;
        }

        handleCardClick(cardItem) {
          try {
            const cardId = cardItem.getAttribute('data-card-id');
            console.log('Clicked card with ID:', cardId);
            console.log('Available cards in cardsData:', Array.from(this.cardsData.keys()));
            console.log('Looking for card with ID:', cardId);

            const cardData = this.cardsData.get(cardId);

            if (cardData) {
              console.log('Selected card:', cardData.name);
              this.showCardModal(cardData);
            } else {
              console.error('Card data not found for ID:', cardId);
              console.error('Available card IDs:', Array.from(this.cardsData.keys()));
            }
          } catch (e) {
            console.error('Error handling card click:', e);
          }
        }

        showCardModal(card) {
          const modalOverlay = document.getElementById('modalOverlay');
          const modalContent = document.getElementById('modalContent');

          // Create modal content
          const imageLarge = this.buildImageUrl(card, '745');
          // Build image element
          let imageHtml = '';
          if (imageLarge) {
            const imgTag = `<img class="modal-image" src="${this.escapeHtml(imageLarge)}" width="745" height="1040" alt="${this.escapeHtml(card.name || 'Card Image')}" />`;
            if (card.set_code && card.collector_number) {
              // Build manapool.com referral URL
              // Set codes and collector numbers from our database are safe for URLs
              const manapoolUrl = `https://manapool.com/card/${card.set_code.toLowerCase()}/${card.collector_number}?ref=arcane-tutor`;
              imageHtml = `<div class="modal-image-wrapper"><a href="${manapoolUrl}" target="_blank" rel="noopener noreferrer" class="modal-image-link">${imgTag}</a></div>`;
            } else {
              imageHtml = `<div class="modal-image-wrapper">${imgTag}</div>`;
            }
          }

          modalContent.innerHTML = `
            <button class="modal-close" onclick="cardSearch.closeModal()">&times;</button>
            ${imageHtml}
            <div class="modal-card-info">
              <div class="modal-card-name-mana-row">
                <div class="modal-card-name">${this.escapeHtml(card.name || 'Unknown Card')}</div>
                ${card.mana_cost ? `<div class="modal-card-mana">${this.convertManaSymbols(card.mana_cost, true)}</div>` : ''}
              </div>
              ${card.type_line ? `<div class="modal-card-type">${this.escapeHtml(card.type_line)}</div>` : ''}
              ${card.oracle_text ? `<div class="modal-card-text">${this.formatOracleText(card.oracle_text, true)}</div>` : ''}
              ${(() => {
                const hasPowerToughness =
                  card.power !== null &&
                  card.power !== undefined &&
                  card.toughness !== null &&
                  card.toughness !== undefined;
                return card.set_name || hasPowerToughness
                  ? `
              <div class="modal-card-set-power-row">
                ${card.set_name ? `<div class="modal-card-set">${this.escapeHtml(card.set_name)}</div>` : '<div class="modal-card-set"></div>'}
                ${hasPowerToughness ? `<div class="modal-card-power-toughness">${this.escapeHtml(card.power)} / ${this.escapeHtml(card.toughness)}</div>` : ''}
              </div>
              `
                  : '';
              })()}
            </div>
          `;

          // Show modal
          modalOverlay.style.display = 'flex';

          // Prevent background scrolling more comprehensively
          this.preventBackgroundScroll();

          // Add click outside to close
          modalOverlay.onclick = e => {
            if (e.target === modalOverlay) {
              this.closeModal();
            }
          };

          // Add escape key to close
          document.addEventListener('keydown', this.handleEscapeKey);
        }

        closeModal() {
          const modalOverlay = document.getElementById('modalOverlay');
          modalOverlay.style.display = 'none';

          // Restore background scrolling
          this.restoreBackgroundScroll();

          document.removeEventListener('keydown', this.handleEscapeKey);
        }

        handleEscapeKey = e => {
          if (e.key === 'Escape') {
            this.closeModal();
          }
        };

        preventBackgroundScroll() {
          // Store the current scroll position
          this.scrollPosition = window.pageYOffset || document.documentElement.scrollTop;

          // Prevent scrolling on body
          document.body.style.overflow = 'hidden';
          document.body.style.position = 'fixed';
          document.body.style.top = `-${this.scrollPosition}px`;
          document.body.style.width = '100%';

          // Prevent touch events on the body (for mobile)
          document.body.addEventListener('touchmove', this.preventTouchMove, { passive: false });
        }

        restoreBackgroundScroll() {
          // Restore body styles
          document.body.style.overflow = '';
          document.body.style.position = '';
          document.body.style.top = '';
          document.body.style.width = '';

          // Restore scroll position
          if (this.scrollPosition !== undefined) {
            window.scrollTo(0, this.scrollPosition);
          }

          // Remove touch event listener
          document.body.removeEventListener('touchmove', this.preventTouchMove);
        }

        preventTouchMove = e => {
          // Allow touch events only on the modal content
          const modalContent = document.getElementById('modalContent');
          if (modalContent && !modalContent.contains(e.target)) {
            e.preventDefault();
          }
        };

        initImageObserver() {
          // Create intersection observer to watch for images entering viewport
          this.imageObserver = new IntersectionObserver(
            entries => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  const img = entry.target;
                  this.loadImage(img);
                  // Stop observing once image is loaded
                  this.imageObserver.unobserve(img);
                }
              });
            },
            {
              rootMargin: '150px', // Start loading 150px before entering viewport
              threshold: 0.1,
            }
          );
        }

        loadImage(imgElement) {
          const smallImageUrl = imgElement.getAttribute('data-small');
          const normalImageUrl = imgElement.getAttribute('data-normal');

          if (!smallImageUrl) return;

          // Start with small image
          imgElement.src = smallImageUrl;

          // If normal image is available, upgrade after small image loads
          if (normalImageUrl) {
            imgElement.onload = () => {
              this.upgradeToNormalImage(imgElement, normalImageUrl);
            };
          }
        }

        upgradeToNormalImage(imgElement, normalImageUrl) {
          // Create a new image to preload the normal version
          const normalImg = new Image();
          normalImg.onload = () => {
            // Once the normal image is loaded, replace the src
            imgElement.src = normalImageUrl;
            imgElement.removeAttribute('data-normal');
            imgElement.removeAttribute('data-small');
            imgElement.onload = null;
          };
          normalImg.onerror = () => {
            // If normal image fails to load, keep the small image
            console.warn('Failed to load normal image:', normalImageUrl);
            imgElement.removeAttribute('data-normal');
            imgElement.removeAttribute('data-small');
            imgElement.onload = null;
          };
          normalImg.src = normalImageUrl;
        }

        observeImages() {
          // Find all images that haven't been loaded yet
          const images = this.resultsContainer.querySelectorAll('img.card-image:not([src])');
          images.forEach(img => {
            this.imageObserver.observe(img);
          });
        }

        showLoading() {
          console.debug('Showing loading');
          // Do not toggle card/result visibility; only update the status container
          if (this.statusMessage) {
            this.statusMessage.innerHTML = '<div class="results-count">Loadingâ€¦</div>';
          }
          this.clearResultsContainer();
        }

        showError(message) {
          console.log('Showing error:', message);
          if (this.statusMessage) {
            this.statusMessage.innerHTML = `<div class="error-message">${this.escapeHtml(message)}</div>`;
          }
          this.clearResultsContainer();
        }

        showNoResults() {
          console.log('Showing no results');
          if (this.statusMessage) {
            this.statusMessage.innerHTML = '<div class="no-results">No cards found matching your search.</div>';
          }
          this.clearResultsContainer();
        }

        clearResultsContainer() {
          this.resultsContainer.innerHTML = '';
        }

        showResultsCount(count, query, elapsed) {
          console.log('Showing results count:', count, query, elapsed);
          const formattedCount = count.toLocaleString();
          const uniqueValue = this.uniqueDropdown.value;
          const itemType = uniqueValue + (count !== 1 ? 's' : '');

          let msg = `Found ${formattedCount} ${itemType} matching "${query}"`;
          if (typeof elapsed === 'number') {
            msg += ` (completed in ${elapsed}ms)`;
          }
          if (this.statusMessage) {
            this.statusMessage.innerHTML = `<div class="results-count">${this.escapeHtml(msg)}</div>`;
          }
        }

        clearResults() {
          // Disconnect observer to clean up
          if (this.imageObserver) {
            this.imageObserver.disconnect();
          }
          this.resultsContainer.innerHTML = '';
          this.currentCardCount = 0; // Reset card count
          this.clearMessages();
        }

        clearSearch() {
          // Clear the search input
          this.searchInput.value = '';

          // Clear results
          this.clearResults();

          // Clear URL parameters
          this.updateURL(
            '',
            this.orderDropdown.value,
            this.isAscending ? 'asc' : 'desc',
            this.uniqueDropdown.value,
            this.preferDropdown.value
          );

          // Focus back on search input
          this.searchInput.focus();
        }

        clearMessages() {
          if (this.statusMessage) {
            this.statusMessage.innerHTML = '';
          }
        }

        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        convertManaSymbolsToText(text) {
          if (!text) return '';

          // Use cached regex pattern and map for performance
          // Reset regex state before use (important for 'g' flag)
          this.manaTextRegex.lastIndex = 0;

          // Replace all symbols in a single pass using a callback function
          // Only replace if the symbol exists in our map, otherwise return unchanged
          return text.replace(this.manaTextRegex, match => {
            const replacement = this.manaTextMap.get(match);
            if (replacement === undefined) {
              return match;
            }
            return replacement;
          });
        }

        convertManaSymbols(manaCost, isModal = false) {
          if (!manaCost) return '';

          const symbolClass = isModal ? 'modal-mana-symbol' : 'mana-symbol';

          // Use cached regex pattern and map for performance
          // Reset regex state before use (important for 'g' flag)
          this.manaSymbolsRegex.lastIndex = 0;

          // Replace all symbols in a single pass using a callback function
          // Only replace if the symbol exists in our map, otherwise return unchanged
          return manaCost.replace(this.manaSymbolsRegex, match => {
            const replacement = this.manaSymbolsMap.get(match);
            if (replacement === undefined) {
              return match;
            }
            return `<span class="${symbolClass} ${replacement}"></span>`;
          });
        }

        formatOracleText(oracleText, isModal = false) {
          if (!oracleText) return '';

          // First convert mana symbols
          let formatted = this.convertManaSymbols(oracleText, isModal);

          // Then convert newlines to HTML line breaks
          formatted = formatted.replace(/\n/g, '<br>');

          return formatted;
        }

        updateOrderToggleAppearance() {
          if (this.isAscending) {
            this.orderToggle.classList.remove('descending');
          } else {
            this.orderToggle.classList.add('descending');
          }
        }

        updateURL(query, order, direction, unique, prefer) {
          const url = new URL(window.location);

          // Define default values
          const defaults = {
            orderby: 'edhrec',
            direction: 'asc',
            unique: 'card',
            prefer: 'default',
          };

          if (query.trim()) {
            // Always include the query parameter
            url.searchParams.set('q', query);

            // Only include parameters that differ from defaults
            if (order !== defaults.orderby) {
              url.searchParams.set('orderby', order);
            } else {
              url.searchParams.delete('orderby');
            }

            if (direction !== defaults.direction) {
              url.searchParams.set('direction', direction);
            } else {
              url.searchParams.delete('direction');
            }

            if (unique !== defaults.unique) {
              url.searchParams.set('unique', unique);
            } else {
              url.searchParams.delete('unique');
            }

            // Handle prefer parameter - only include if unique is not 'printing' and prefer is not default
            if (unique !== UNIQUE_PRINTING && prefer !== defaults.prefer) {
              url.searchParams.set('prefer', prefer);
            } else {
              url.searchParams.delete('prefer');
            }
          } else {
            // Clear all parameters when no query
            url.searchParams.delete('q');
            url.searchParams.delete('orderby');
            url.searchParams.delete('direction');
            url.searchParams.delete('unique');
            url.searchParams.delete('prefer');
          }
          window.history.replaceState({}, '', url);
        }

        updatePreferVisibility() {
          const isPrinting = this.uniqueDropdown.value === UNIQUE_PRINTING;
          this.preferDropdown.style.display = isPrinting ? 'none' : '';
          this.preferDropdown.disabled = isPrinting;
        }

        handleOrderChange() {
          // Update URL with current state
          const query = this.searchInput.value.trim();
          const order = this.orderDropdown.value;
          const unique = this.uniqueDropdown.value;
          const prefer = this.preferDropdown.value;
          const direction = this.isAscending ? 'asc' : 'desc';
          this.updateURL(query, order, direction, unique, prefer);

          // Trigger a new search with the current query and new order
          if (query) {
            this.performSearch(query);
          }
        }

        handleUniqueChange() {
          // Update URL with current state
          const query = this.searchInput.value.trim();
          const order = this.orderDropdown.value;
          const unique = this.uniqueDropdown.value;
          const prefer = this.preferDropdown.value;
          const direction = this.isAscending ? 'asc' : 'desc';
          this.updateURL(query, order, direction, unique, prefer);

          // Trigger a new search with the current query and new unique setting
          if (query) {
            this.performSearch(query);
          }
        }

        handlePreferChange() {
          // Update URL with current state
          const query = this.searchInput.value.trim();
          const order = this.orderDropdown.value;
          const unique = this.uniqueDropdown.value;
          const prefer = this.preferDropdown.value;
          const direction = this.isAscending ? 'asc' : 'desc';
          this.updateURL(query, order, direction, unique, prefer);

          // Trigger a new search with the current query and new prefer setting
          if (query) {
            this.performSearch(query);
          }
        }

        toggleOrderDirection() {
          this.isAscending = !this.isAscending;
          this.updateOrderToggleAppearance();

          // Update URL with current state
          const query = this.searchInput.value.trim();
          const order = this.orderDropdown.value;
          const unique = this.uniqueDropdown.value;
          const prefer = this.preferDropdown.value;
          const direction = this.isAscending ? 'asc' : 'desc';
          this.directionInput.value = direction;
          this.updateURL(query, order, direction, unique, prefer);

          // Trigger a new search with the current query and new order direction
          if (query) {
            this.performSearch(query);
          }
        }
      }

      /* Theme switching functionality */
      class ThemeManager {
        constructor() {
          this.themeToggle = document.getElementById('themeToggle');
          this.themeIcon = document.getElementById('themeIcon');
          this.currentTheme = localStorage.getItem('theme') || 'dark';

          this.init();
        }

        init() {
          // Apply saved theme
          this.applyTheme(this.currentTheme);

          // Add click event listener
          if (this.themeToggle) {
            this.themeToggle.addEventListener('click', e => {
              e.preventDefault();
              e.stopPropagation();
              this.toggleTheme();
            });
          }
        }

        toggleTheme() {
          this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
          this.applyTheme(this.currentTheme);
          this.saveTheme();
        }

        applyTheme(theme) {
          document.documentElement.setAttribute('data-theme', theme);
          this.updateIcon(theme);
        }

        updateIcon(theme) {
          if (this.themeIcon) {
            this.themeIcon.textContent = theme === 'light' ? 'ðŸŒ™' : 'â˜€ï¸';
          }
        }

        saveTheme() {
          localStorage.setItem('theme', this.currentTheme);
        }
      }

      // Apply initial theme immediately to prevent flash
      (function () {
        let savedTheme = 'dark';
        try {
          const theme = localStorage.getItem('theme');
          if (theme) savedTheme = theme;
        } catch (e) {
          // localStorage may be unavailable; fallback to default theme
        }
        document.documentElement.setAttribute('data-theme', savedTheme);
      })();

      window.cardSearchMain = function () {
        window.cardSearch = new CardSearch();
        window.themeManager = new ThemeManager();
      };
    </script>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
          <span id="themeIcon">â˜€ï¸</span>
        </button>
        <h1>Arcane Tutor</h1>
        <p>Search for Magic: The Gathering cards</p>
      </div>

      <form method="GET" action="" class="search-container">
        <div class="search-box">
          <input
            type="text"
            class="search-input"
            placeholder="Search for cards by name, type, or text..."
            id="searchInput"
            name="q"
          />
          <div class="loading" id="loading">
            <div class="spinner"></div>
          </div>
        </div>
        <div class="order-controls">
          <label for="orderDropdown" class="dropdown-label">Order By:</label>
          <select class="order-dropdown" id="orderDropdown" name="orderby">
            <option value="edhrec">EDHREC</option>
            <option value="cmc">CMC</option>
            <option value="power">Power</option>
            <option value="toughness">Toughness</option>
            <option value="rarity">Rarity</option>
            <option value="usd">USD</option>
          </select>
          <label for="uniqueDropdown" class="dropdown-label">Unique Mode:</label>
          <select class="order-dropdown" id="uniqueDropdown" name="unique">
            <option value="card">Cards</option>
            <option value="artwork">Artwork</option>
            <option value="printing">Printings</option>
          </select>
          <label for="preferDropdown" class="dropdown-label">Prefer:</label>
          <select class="order-dropdown" id="preferDropdown" name="prefer">
            <option value="default">Default</option>
            <option value="oldest">Oldest</option>
            <option value="newest">Newest</option>
            <option value="usd-low">$ Low</option>
            <option value="usd-high">$ High</option>
            <option value="promo">Promo</option>
          </select>
          <input type="hidden" name="direction" id="directionInput" value="asc" />
          <button type="button" class="order-toggle" id="orderToggle" title="Toggle ascending/descending">
            <span class="arrow-up">â†‘</span>
          </button>
        </div>
      </form>

      <div id="statusMessage" aria-live="polite"><!-- SERVER_SIDE_RESULTS_COUNT --></div>
      <div id="results" class="results-container"><!-- SERVER_SIDE_RESULTS --></div>

      <footer class="footer">
        <p class="footer-legal">
          Magic: The Gatheringâ„¢ is a trademark of Wizards of the Coast LLC, a subsidiary of Hasbro, Inc.
          <br />
          Â© Wizards of the Coast LLC. Not approved/endorsed by Wizards of the Coast.
        </p>
        <p class="footer-attribution">
          Card data provided by <a href="https://scryfall.com" target="_blank" rel="noopener">Scryfall</a>.
          <br />
          Arcane Tutor is an independent open-source project, not affiliated with Scryfall.
        </p>
        <p class="footer-links">
          <a href="https://github.com/jbylund/arcane_tutor" target="_blank" rel="noopener">GitHub</a>
          Â·
          <a
            href="https://github.com/jbylund/arcane_tutor/blob/main/docs/terms_of_service.md"
            target="_blank"
            rel="noopener"
            >Terms of Service</a
          >
          Â·
          <a
            href="https://github.com/jbylund/arcane_tutor/blob/main/docs/privacy_policy.md"
            target="_blank"
            rel="noopener"
            >Privacy Policy</a
          >
          Â·
          <a href="https://company.wizards.com/en/legal/fancontentpolicy" target="_blank" rel="noopener"
            >Wizards Fan Content Policy</a
          >
        </p>
      </footer>
    </div>

    <!-- Modal for card details -->
    <div id="modalOverlay" class="modal-overlay">
      <div id="modalContent" class="modal-content">
        <!-- Modal content will be dynamically inserted here -->
      </div>
    </div>
    <script>
      <!-- SERVER_SIDE_EMBEDDED_DATA -->
      window.cardSearchMain && window.cardSearchMain();
    </script>
  </body>
</html>
